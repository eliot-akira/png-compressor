{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/png/encode.ts", "../../src/compress.ts", "../../src/json-array-buffer.ts", "../../src/encode.ts", "../../src/png/decode.ts", "../../src/decode.ts"],
  "sourcesContent": ["export * from './encode.js'\nexport * from './decode.js'\n", "/**\n * Encode data as PNG (4 GiB maximum).\n */\nexport async function encodeBufferToPng(\n  buffer: ArrayBuffer,\n): Promise<ArrayBuffer> {\n  const blob = await encodeBufferToCanvasBlob(buffer)\n  return await blob.arrayBuffer()\n}\n\nexport async function encodeBufferToCanvasBlob(\n  buffer: ArrayBuffer,\n): Promise<Blob> {\n  const data = new Uint8Array(buffer)\n\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d')\n    const size = Math.ceil(Math.sqrt(data.length / 3 + 1))\n    const w = (canvas.width = size)\n    const h = (canvas.height = size)\n    const image = ctx?.getImageData(0, 0, w, h)!\n\n    dataToImage(data, image.data)\n\n    ctx?.putImageData(image, 0, 0)\n\n    canvas.toBlob((blob) => {\n      if (!blob) reject(new Error('Canvas failed to create blob'))\n      else resolve(blob)\n    }, 'image/png')\n  })\n}\n\nexport function dataToImage(data: Uint8Array, img: Uint8ClampedArray) {\n  for (let i = 0, size = data.length; i < 3; i++) {\n    img[i] = (size / Math.pow(256, i)) % 256 | 0\n  }\n  img[3] = 255\n  for (let i = 4, j = 0, l = img.length; i < l; i += 4, j += 3) {\n    img[i] = data[j] || 0\n    img[i + 1] = data[j + 1] || 0\n    img[i + 2] = data[j + 2] || 0\n    img[i + 3] = 255 // Opacity is unused because it can affect color values\n  }\n  return img\n}\n", "// Browser and server\nconst { CompressionStream, DecompressionStream, Response } = globalThis\n\ntype CompressionFormat = 'gzip' | 'deflate' | 'deflate-raw'\n\nexport const defaultCompressionFormat = 'gzip'\n\n/**\n * Compress array buffer\n */\nexport async function compress(\n  data: string | ArrayBuffer,\n  compressionFormat: CompressionFormat = defaultCompressionFormat,\n): Promise<ArrayBuffer> {\n  const compressor = new CompressionStream(compressionFormat)\n  const stream = new Response(data).body?.pipeThrough(compressor)\n  return await new Response(stream).arrayBuffer()\n}\n\nasync function decompressAsResponse(\n  bytes: ArrayBuffer,\n  compressionFormat: CompressionFormat = defaultCompressionFormat,\n): Promise<Response> {\n  const decompressor = new DecompressionStream(compressionFormat)\n  const stream = new Response(bytes).body?.pipeThrough(decompressor)\n  return new Response(stream)\n}\n\nexport async function decompressAsArrayBuffer(\n  bytes: ArrayBuffer,\n  compressionFormat: CompressionFormat = defaultCompressionFormat,\n): Promise<ArrayBuffer> {\n  return (await decompressAsResponse(bytes, compressionFormat)).arrayBuffer()\n}\n\nexport async function decompressAsString(\n  bytes: ArrayBuffer,\n  compressionFormat: CompressionFormat = defaultCompressionFormat,\n): Promise<string> {\n  return (await decompressAsResponse(bytes, compressionFormat)).text()\n}\n\nexport { decompressAsArrayBuffer as decompress }\n", "/**\n * Convert JSON-serializable value to array buffer\n */\nexport function valueToArrayBuffer(value: any): ArrayBuffer {\n  // Value -> JSON String -> Uint8Array -> ArrayBuffer\n  return new TextEncoder().encode(JSON.stringify(value)).buffer\n}\n\n/**\n * Convert array buffer to JSON-serializable value\n */\nexport function arrayBufferToValue(buffer: ArrayBuffer) {\n  // ArrayBuffer -> JSON String -> Value\n  return JSON.parse(new TextDecoder().decode(buffer))\n}\n", "import { encodeBufferToPng, encodeBufferToCanvasBlob } from './png/encode.js'\nimport { compress } from './compress.js'\nimport { valueToArrayBuffer } from './json-array-buffer.js'\n\n/**\n * Encode JSON-serializable value to PNG image data as array buffer\n */\nexport async function encode(value: any): Promise<ArrayBuffer> {\n  return await encodeBufferToPng(await compress(valueToArrayBuffer(value)))\n}\n\n/**\n * Encode JSON-serializable value to PNG image data as blob\n */\nexport async function encodeToBlob(value: any): Promise<Blob> {\n  return await encodeBufferToCanvasBlob(\n    await compress(valueToArrayBuffer(value)),\n  )\n}\n", "/**\n * Decode data from PNG\n */\nexport async function decodeBufferFromPng(\n  buffer: ArrayBuffer,\n): Promise<ArrayBuffer> {\n  const blob = new Blob([buffer])\n\n  return new Promise((resolve, reject) => {\n    const img = new Image()\n    img.onload = function () {\n      const canvas = document.createElement('canvas')\n      const ctx = canvas.getContext('2d')\n      const w = (canvas.width = img.width)\n      const h = (canvas.height = img.height)\n      ctx.drawImage(img, 0, 0)\n      const imgData = ctx.getImageData(0, 0, w, h).data\n\n      const data = imageToData(imgData)\n\n      URL.revokeObjectURL(img.src)\n      resolve(\n        data,\n        // new Blob([data], { type: 'application/octet-binary' })\n      )\n    }\n    img.onerror = reject\n    img.src = URL.createObjectURL(blob)\n  })\n}\n\nexport function imageToData(img: Uint8ClampedArray): ArrayBuffer {\n  let size = 0\n  for (let i = 0; i < 3; i++) {\n    size += img[i] * Math.pow(256, i)\n  }\n  const data = new Uint8Array(size)\n\n  root: for (let i = 4, j = 0, l = img.length; j < l; i += 4, j += 3) {\n    for (let k = 0; k < 3; k++) {\n      if (j + k >= size) break root\n      data[j + k] = img[i + k]\n    }\n  }\n  return data.buffer\n}\n", "import { decodeBufferFromPng } from './png/decode.js'\nimport { decompressAsArrayBuffer } from './compress.js'\nimport { arrayBufferToValue } from './json-array-buffer.js'\n\n/**\n * Decode PNG image data to JSON-serializable value\n */\nexport async function decode(buffer: ArrayBuffer): Promise<any> {\n  return arrayBufferToValue(\n    await decompressAsArrayBuffer(\n      await decodeBufferFromPng(buffer), // Decode PNG to array buffer\n    ),\n  )\n}\n\n/**\n * Decode PNG image data to array buffer\n */\nexport async function decodeBuffer(buffer: ArrayBuffer): Promise<ArrayBuffer> {\n  return await decompressAsArrayBuffer(await decodeBufferFromPng(buffer))\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "decode", "decodeBuffer", "encode", "encodeToBlob", "encodeBufferToPng", "buffer", "encodeBufferToCanvasBlob", "data", "resolve", "reject", "canvas", "ctx", "size", "w", "h", "image", "dataToImage", "blob", "img", "i", "j", "l", "CompressionStream", "DecompressionStream", "Response", "defaultCompressionFormat", "compress", "data", "compressionFormat", "compressor", "stream", "decompressAsResponse", "bytes", "decompressor", "decompressAsArrayBuffer", "valueToArrayBuffer", "value", "arrayBufferToValue", "buffer", "encode", "value", "encodeBufferToPng", "compress", "valueToArrayBuffer", "encodeToBlob", "encodeBufferToCanvasBlob", "decodeBufferFromPng", "buffer", "blob", "resolve", "reject", "img", "canvas", "ctx", "w", "h", "imgData", "data", "imageToData", "size", "i", "root", "j", "l", "k", "decode", "buffer", "arrayBufferToValue", "decompressAsArrayBuffer", "decodeBufferFromPng", "decodeBuffer"]
}
