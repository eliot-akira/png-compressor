{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/png.ts", "../../src/compress.ts"],
  "sourcesContent": ["import { encodePng, encodePngBlob, decodePng } from './png.js'\nimport {\n  compress,\n  decompressAsString,\n  decompressAsArrayBuffer,\n} from './compress.js'\n\nexport async function encode(value: any): Promise<ArrayBuffer> {\n  return await encodePng(await compress(JSON.stringify(value)))\n}\n\nexport async function decode(buffer: ArrayBuffer): Promise<any> {\n  return JSON.parse(await decompressAsString(await decodePng(buffer)))\n}\n\nexport async function encodeBinary(value: ArrayBuffer): Promise<ArrayBuffer> {\n  return await encodePng(await compress(value))\n}\n\nexport async function decodeBinary(buffer: ArrayBuffer): Promise<ArrayBuffer> {\n  return await decompressAsArrayBuffer(await decodePng(buffer))\n}\n\nexport async function encodeBlob(value: any): Promise<Blob> {\n  return await encodePngBlob(await compress(JSON.stringify(value)))\n}\n", "/**\n * Encode data as PNG (4 GiB maximum).\n */\nexport async function encodePng(buffer: ArrayBuffer): Promise<ArrayBuffer> {\n  const blob = await encodePngBlob(buffer)\n  return await blob.arrayBuffer()\n}\n\nexport async function encodePngBlob(buffer: ArrayBuffer): Promise<Blob> {\n  const data = new Uint8Array(buffer)\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d')\n    const size = Math.ceil(Math.sqrt(data.length / 3 + 1))\n    const w = (canvas.width = size)\n    const h = (canvas.height = size)\n    const image = ctx?.getImageData(0, 0, w, h)!\n\n    dataToImage(data, image.data)\n\n    ctx?.putImageData(image, 0, 0)\n\n    canvas.toBlob((blob) => {\n      if (!blob) reject(new Error('Canvas failed to create blob'))\n      else resolve(blob)\n    }, 'image/png')\n  })\n}\n\nexport function dataToImage(data: Uint8Array, img: Uint8ClampedArray) {\n  for (let i = 0, size = data.length; i < 3; i++) {\n    img[i] = (size / Math.pow(256, i)) % 256 | 0\n  }\n  img[3] = 255\n  for (let i = 4, j = 0, l = img.length; i < l; i += 4, j += 3) {\n    img[i] = data[j] || 0\n    img[i + 1] = data[j + 1] || 0\n    img[i + 2] = data[j + 2] || 0\n    img[i + 3] = 255\n  }\n  return img\n}\n\n/**\n * Decode data from PNG.\n */\nexport async function decodePng(buffer: ArrayBuffer): Promise<ArrayBuffer> {\n  const blob = new Blob([buffer])\n  return new Promise((resolve, reject) => {\n    const img = new Image()\n    img.onload = function () {\n      const canvas = document.createElement('canvas')\n      const ctx = canvas.getContext('2d')\n      const w = (canvas.width = img.width)\n      const h = (canvas.height = img.height)\n      ctx.drawImage(img, 0, 0)\n      const imgData = ctx.getImageData(0, 0, w, h).data\n      const data = imageToData(imgData)\n      URL.revokeObjectURL(img.src)\n      resolve(\n        data\n        // new Blob([data], { type: 'application/octet-binary' })\n      )\n    }\n    img.onerror = reject\n    img.src = URL.createObjectURL(blob)\n  })\n}\n\nexport function imageToData(img: Uint8ClampedArray) {\n  let size = 0\n  for (let i = 0; i < 3; i++) {\n    size += img[i] * Math.pow(256, i)\n  }\n  const data = new Uint8Array(size)\n\n  root: for (let i = 4, j = 0, l = img.length; j < l; i += 4, j += 3) {\n    for (let k = 0; k < 3; k++) {\n      if (j + k >= size) break root\n      data[j + k] = img[i + k]\n    }\n  }\n  return data.buffer\n}\n", "// Browser and server\nconst { CompressionStream, DecompressionStream, Response } = globalThis\n\ntype CompressionFormat = 'gzip' | 'deflate' | 'deflate-raw'\n\nexport const defaultCompressionFormat = 'gzip'\n\nexport async function compress(\n  data: string | ArrayBuffer,\n  compressionFormat: CompressionFormat = defaultCompressionFormat,\n): Promise<ArrayBuffer> {\n  const compressor = new CompressionStream(compressionFormat)\n  const stream = new Response(data).body?.pipeThrough(compressor)\n  return await new Response(stream).arrayBuffer()\n}\n\nasync function decompressAsResponse(\n  bytes: ArrayBuffer,\n  compressionFormat: CompressionFormat = defaultCompressionFormat,\n): Promise<Response> {\n  const decompressor = new DecompressionStream(compressionFormat)\n  const stream = new Response(bytes).body?.pipeThrough(decompressor)\n  return new Response(stream)\n}\n\nexport async function decompressAsArrayBuffer(\n  bytes: ArrayBuffer,\n  compressionFormat: CompressionFormat = defaultCompressionFormat,\n): Promise<ArrayBuffer> {\n  return (await decompressAsResponse(bytes, compressionFormat)).arrayBuffer()\n}\n\nexport async function decompressAsString(\n  bytes: ArrayBuffer,\n  compressionFormat: CompressionFormat = defaultCompressionFormat,\n): Promise<string> {\n  return (await decompressAsResponse(bytes, compressionFormat)).text()\n}\n\nexport { decompressAsArrayBuffer as decompress }\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "decode", "decodeBinary", "encode", "encodeBinary", "encodeBlob", "encodePng", "buffer", "encodePngBlob", "data", "resolve", "reject", "canvas", "ctx", "size", "w", "h", "image", "dataToImage", "blob", "img", "i", "j", "l", "decodePng", "imgData", "imageToData", "root", "k", "CompressionStream", "DecompressionStream", "Response", "defaultCompressionFormat", "compress", "data", "compressionFormat", "compressor", "stream", "decompressAsResponse", "bytes", "decompressor", "decompressAsArrayBuffer", "decompressAsString", "encode", "value", "encodePng", "compress", "decode", "buffer", "decompressAsString", "decodePng", "encodeBinary", "decodeBinary", "decompressAsArrayBuffer", "encodeBlob", "encodePngBlob"]
}
